---
title: 【JVM内存】JVM内存分布
date: 2015-9-14 16:42:20
tags:  JVM内存分布
reward: true
---

#  JVM内存分布

工欲善其事，必先利其器。曾经的我经常害怕处理内存溢出的问题，因为不知道他为什么会出现这个问题，当我在看了这本书以后明白了垃圾回收算法，以及JVM是如何帮助我们处理GC的，这个时候当出现这个问题的时候我就明白需要查找GC Root，或者查看GC日志，去查找这个问题的根源，这样就能处理这些问题。还有以前的在理解重载和重构的时候只是在表面去理解，当我看完这本书明白，原来在方法调用时候这些东西就生成处理，另外还有一个new到底经历那些事情等等一序列问题，如果你还在就纠结一些问题为什么是这么处理的时候那你就去看Java虚拟机吧！

<!--more-->
内存大致分布：

![](https://i.imgur.com/tEZop1t.png)

1.线程独有的内存区域

###①程序计数器

是一块较小的内存空间，用来指定当前线程执行字节码的行数，每个线程计数器都是私有的，因为每个线程都需要记录执行的行数；这里解释一下为什么每个线程都需要一个线程计数器，JVM的多线程是通过线程轮流切换分配执行时间来实现的，在任何时刻，每个处理器都只会执行一个线程中的指令，当线程进行切换的时，为了线程能恢复当正确的位置，所以每个线程必须有个独立的线程计数器，这样才能保证线程之间不互相影响。


###②虚拟机栈
生命周期和线程相同，每个方法执行的时候都会创建一个栈帧，用于存储局部变量表，操作数栈，动态链接，方法出口等信息，每一个方法从调用直至执行完毕的过程，就对应着一个栈帧的入栈到出栈的过程，栈的大小和具体的JVM实现有关，通常在256K~756K之间。

     这里解释一下局部变量表，局部变量表存储方法相关的局部变量，包括基本数据，对象引用和返回地址等。在局部变量表中，只有long和double类型会占用2个局部变量空间（Slot，对于32位机器，一个Slot就是32个bit），
     其它都是1个Slot。需要注意的是，局部变量表是在编译时就已经确定好的，
     方法运行所需要分配的空间在栈帧中是完全确定的，在方法的生命周期内都不会改变。
     这部分东西我还想等下一篇博客的时候我想仔细说一下字节码的执行过程；

     虚拟机栈规定了２种异常情况，一种是线程请求栈的深度大于虚拟机栈所允许的深度，这时候将会抛出StackOverflowError异常，如果当Java虚拟机允许动态扩展虚拟机栈的时候，
	 当扩展的时候没办法分配到内存的时候就会报OutOfMemoryError异常；


###③NATIVE METHOD STACK，方法栈

和虚拟机栈起的作用一样，只不过方法栈为虚拟机使用到的Native方法服务。虚拟机规范并没有对这个区域有什么强制规定，因此我们使用的HotSpot虚拟机，就干脆没有这块区域了，它和虚拟机栈是一起的。

##2.线程之间的共享的内存区域

###① HEAP，堆

大多数应用，堆都是Java虚拟机所管理的内存中最大的一块，它在虚拟机启动时创建，此内存唯一的目的就是存放对象实例。由于现在垃圾收集器采用的基本都是分代收集算法，所以堆还可以细分为新生代和老年代，再细致一点还有Eden区、From Survivior区、To Survivor区，这个后面都会讲到的。

② METHOD AREA，方法区

这块区域用于存储虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据，虚拟机规范是把这块区域描述为堆的一个逻辑部分的，但实际它应该是要和堆区分开的。从上面提到的分代收集算法的角度看，HotSpot中，方法区≈永久代。不过JDK 7之后，我们使用的HotSpot应该就没有永久代这个概念了，会采用Native Memory来实现方法区的规划了。

###③ RUNTIME CONSTANT POOL，运行时常量池

上面的图中没有画出来，因为它是方法区的一部分。Class文件中除了有类的版本信息、字段、方法、接口等描述信息外，还有一项信息就是常量池，用于存放编译期间生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中，另外翻译出来的直接引用也会存储在这个区域中。这个区域另外一个特点就是动态性，Java并不要求常量就一定要在编译期间才能产生，运行期间也可以在这个区域放入新的内容，String.intern()方法就是这个特性的应用。

###④ 直接内存
不是虚拟机运行时的一部分，可以直接访问堆外的内存；所以当内存空间无法动态扩展的时候就会出现OutOfMemoryError异常


  以上基本是JVM内存分布的内容，简单的理解水满则溢出就是这个道理，系统的整个空间是一个大的容器，分不同的部分或者桶去分担整个容量，当那个桶不够的时候自然会溢出。明白内存区域的分布我们看下对象是如何分配在内存空间里面的?

  Java对象这里指的是引用类型的对象，这里用Student stu=new Student()为例子访问，Student stu作为引用对象，存在与Java虚拟机栈上，new Student()保存在Java堆中，堆中记录Student类型的信息包括方法，接口，对象类型等地址，这些类型的执行的数据存储在方法区中

###对象访问方式：

###①句柄访问
主要是Java堆中划分一块句柄池，虚拟机栈中存放句柄池中的地址，句柄池中包括对象的实例数据和对象类型的数据的地址，基本分布如下图：
![](https://i.imgur.com/RDQTsIp.png)
###②直接指针访问，

就是虚拟机栈直接指向Java堆中的对象类型指针和对象的实例数据，然后对象类型指针在指向方法区中对象类型的实例数据，分布如下图：
![](https://i.imgur.com/PUsFkDq.png)

 HotSpot就是第二种访问方式，优点在于访问速度快，省去一次指针开销时间

 